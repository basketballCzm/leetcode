/*
判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。


上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 '.' 表示。

示例 1:

输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
示例 2:

输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
说明:

一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
给定数独序列只包含数字 1-9 和字符 '.' 。
给定数独永远是 9x9 形式的。
*/

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;


class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
    	//这三个map相当于某种形式的hash_map
    	int row[10] = {0};
    	int col[10] = {0};
    	//每个小的正方形的9个数字是否重复
    	int cell[10][10] = {0}; 
    	for(int i = 0; i < 10; i++){
    		row[i] = 0;
    		col[i] = 0; 
    		for(int j = 0; j < 10; j++){
    			cell[i][j] = 0;
    		}
    	}

    	for(int i = 0; i < 9; i++){
    		for(int j = 0; j < 9; j++){
    			if('.' != board[i][j]){
    				if(0 != row[board[i][j]-'0']){
    					return false;
    				}
    				row[board[i][j]-'0']++;
    			}

    			if('.' != board[j][i]){
    				if(0 != col[board[j][i]-'0']){
    					return false;
    				}
    				col[board[j][i]-'0']++;
    			}

    			if('.' != board[i][j]){
    				if(0 != cell[(i/3)*3+j/3][board[i][j]-'0']){
    					return false;
    				}
    				cell[(i/3)*3+j/3][board[i][j]-'0']++;
    			}
    		}

    		//这里cell变量是不用回执为0的，因为这个变量是针对两层for循环的全局变量
    		for(int j = 0; j < 10; j++){
    			row[j] = 0;
    			col[j] = 0;
    		}
    	}

    	return true;
    }
};

int main(){
	vector<vector<char>> board;
	board.push_back({'.','.','.','.','5','.','.','1','.'});
	board.push_back({'.','4','.','3','.','.','.','.','.'});
	board.push_back({'.','.','.','.','.','3','.','.','1'});
	board.push_back({'8','.','.','.','.','.','.','2','.'});
	board.push_back({'.','.','2','.','7','.','.','.','.'});
	board.push_back({'.','1','5','.','.','.','.','.','.'});
	board.push_back({'.','.','.','.','.','2','.','.','.'});
	board.push_back({'.','2','.','9','.','.','.','.','.'});
	board.push_back({'.','.','4','.','.','.','.','.','.'});
	Solution s;
	cout << s.isValidSudoku(board) <<endl;
	return 0;
}


